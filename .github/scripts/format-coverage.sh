#!/usr/bin/env bash
set -euo pipefail

# Script to format Go coverage output as a markdown table
# Usage: ./format-coverage.sh coverage.out [current-coverage] [main-coverage]

COVERAGE_FILE="${1:-coverage.out}"
CURRENT_COVERAGE="${2:-}"
MAIN_COVERAGE="${3:-}"

if [ ! -f "$COVERAGE_FILE" ]; then
    echo "Error: Coverage file '$COVERAGE_FILE' not found"
    exit 1
fi

# Start markdown output
echo "## ðŸ“Š Test Coverage Report"
echo ""

# Show current and main coverage if provided
if [ -n "$CURRENT_COVERAGE" ]; then
    echo "**Current Coverage:** \`$CURRENT_COVERAGE\`"
    
    if [ -n "$MAIN_COVERAGE" ]; then
        echo "**Main Branch Coverage:** \`$MAIN_COVERAGE\`"
        echo ""
        
        # Calculate difference
        CURRENT_NUM=$(echo "$CURRENT_COVERAGE" | sed 's/%//')
        MAIN_NUM=$(echo "$MAIN_COVERAGE" | sed 's/%//')
        
        if [ -n "$CURRENT_NUM" ] && [ -n "$MAIN_NUM" ]; then
            DIFF=$(echo "$CURRENT_NUM - $MAIN_NUM" | bc -l 2>/dev/null || echo "0")
            
            if [ "$(echo "$DIFF > 0" | bc -l 2>/dev/null || echo "0")" = "1" ]; then
                echo "**Coverage Change:** ðŸ“ˆ +${DIFF}% (improved)"
            elif [ "$(echo "$DIFF < 0" | bc -l 2>/dev/null || echo "0")" = "1" ]; then
                DIFF_ABS=$(echo "$DIFF * -1" | bc -l 2>/dev/null || echo "${DIFF#-}")
                echo "**Coverage Change:** ðŸ“‰ -${DIFF_ABS}% (decreased)"
            else
                echo "**Coverage Change:** âœ… No change"
            fi
        fi
    fi
fi

echo ""
echo "### Coverage by Package"
echo ""

# Create table header
echo "| Package | Coverage |"
echo "|---------|----------|"

# Parse coverage and group by package
go tool cover -func="$COVERAGE_FILE" | grep -E '\.go:[0-9]+:' | \
awk -F: '{
    # Extract package path from filename
    split($1, parts, "/");
    pkg = "";
    for(i=1; i<length(parts); i++) {
        if(pkg != "") pkg = pkg "/";
        pkg = pkg parts[i];
    }
    
    # Extract coverage percentage from the last field
    split($0, line, /[[:space:]]+/);
    coverage = line[length(line)];
    
    # Store coverage by package
    if(pkg in packages) {
        packages[pkg] = packages[pkg] "," coverage;
    } else {
        packages[pkg] = coverage;
    }
}
END {
    for(pkg in packages) {
        # Calculate average coverage for package
        split(packages[pkg], covs, ",");
        sum = 0;
        count = 0;
        for(i in covs) {
            gsub(/%/, "", covs[i]);
            sum += covs[i];
            count++;
        }
        avg = (count > 0) ? sum/count : 0;
        
        # Format package name (remove common prefix)
        display_pkg = pkg;
        gsub(/github\.com\/speakeasy-api\/openapi\//, "", display_pkg);
        
        # Add emoji indicators based on coverage level
        emoji = "ðŸ”´";
        if(avg >= 90) emoji = "ðŸŸ¢";
        else if(avg >= 75) emoji = "ðŸŸ¡";
        else if(avg >= 50) emoji = "ðŸŸ ";
        
        # Output with coverage value for sorting
        printf "%.1f|`%s`|%s\n", avg, display_pkg, emoji;
    }
}' | sort -n | awk -F'|' '{
    # Re-format after sorting by coverage
    printf "| %s | %s %.1f%% |\n", $2, $3, $1;
}'

echo ""
echo "<details>"
echo "<summary>ðŸ“‹ Detailed Coverage by Function (click to expand)</summary>"
echo ""
echo "\`\`\`"
go tool cover -func="$COVERAGE_FILE"
echo "\`\`\`"
echo "</details>"
echo ""
echo "- ðŸ§ª All tests passed"
echo "- ðŸ“ˆ Full coverage report available in workflow artifacts"
echo ""
echo "_Generated by GitHub Actions_"